{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, ScaledSvg, Html } from 'layercake';\n  import { scaleOrdinal } from 'd3-scale';\n  import { timeParse, timeFormat } from 'd3-time-format';\n  import { format, precisionFixed } from 'd3-format';\n\n  import MultiLine from './_components/MultiLine.svelte';\n  import AxisX from './_components/AxisX.html.svelte';\n  import AxisY from './_components/AxisY.html.svelte';\n  import GroupLabels from './_components/GroupLabels.html.svelte';\n  import SharedTooltip from './_components/SharedTooltip.percent-range.html.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/fruit.csv';\n\n  /* --------------------------------------------\n   * Set what is our x key to separate it from the other series\n   */\n  const xKey = 'month';\n  const yKey = 'value';\n  const zKey = 'fruit';\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = ['#ffe4b8', '#ffb3c0', '#ff7ac7', '#ff00cc'];\n\n  const parseDate = timeParse('%Y-%m-%d');\n\n  /* --------------------------------------------\n   * Create a \"long\" format that is a grouped series of data points\n   * Layer Cake uses this data structure and the key names\n   * set in xKey, yKey and zKey to map your data into each scale.\n   */\n  const dataLong = seriesNames.map(key => {\n    return {\n      [zKey]: key,\n      values: data.map(d => {\n        d[xKey] = typeof d[xKey] === 'string' ? parseDate(d[xKey]) : d[xKey]; // Conditional required for sapper\n        return {\n          [yKey]: +d[key],\n          [xKey]: d[xKey]\n        };\n      })\n    };\n  });\n\n  /* --------------------------------------------\n   * Make a flat array of the `values` of our nested series\n   * we can pluck the field set from `yKey` from each item\n   * in the array to measure the full extents\n   */\n  const flatten = data => data.reduce((memo, group) => {\n    return memo.concat(group.values);\n  }, []);\n\n  const formatTickX = timeFormat('%b. %e');\n  const formatTickY = d => format(`.${precisionFixed(d)}s`)(d);\n</script>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    ssr={true}\n    percentRange={true}\n    padding={{ top: 7, right: 10, bottom: 20, left: 25 }}\n    x={xKey}\n    y={yKey}\n    z={zKey}\n    zScale={scaleOrdinal()}\n    zDomain={seriesNames}\n    zRange={seriesColors}\n    flatData={flatten(dataLong)}\n    yDomain={[0, null]}\n    data={dataLong}\n  >\n    <Html>\n      <AxisX\n        gridlines={false}\n        ticks={data.map(d => d[xKey]).sort((a, b) => a - b)}\n        formatTick={formatTickX}\n        snapTicks={true}\n        tickMarks={true}\n      />\n      <AxisY\n        baseline={true}\n        formatTick={formatTickY}\n      />\n    </Html>\n\n    <ScaledSvg>\n      <MultiLine/>\n    </ScaledSvg>\n\n    <Html>\n      <GroupLabels/>\n      <SharedTooltip\n        formatTitle={formatTickX}\n        dataset={data}\n      />\n    </Html>\n  </LayerCake>\n</div>"},"dek":"A multiline example with a quadtree tooltip. This is an interesting example because the data exists in a few different structures:\n\n1. We're loading data from a \"wide\" format where each series has its own column name. We need to first turn this into...\n2. ...a \"long\" format, where each type of fruit is grouped into its own array and each datapoint is a row. The column name becomes a property on the group whose name we define with the `zKey` variable.\n3. We also need a flat, ungrouped array of objects so that Layer Cake can measure the full data extents. This gets passed to the `flatData` prop so the scales know the full domain of the data.\n","components":[{"title":"./_components/MultiLine.svelte","contents":"<!--\n  @component\n  Generates an SVG multi-series line chart. It expects your data to be an array of objects, each with a `values` key that is an array of data objects.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, zGet } = getContext('LayerCake');\n\n  $: path = values => {\n    return 'M' + values\n      .map(d => {\n        return $xGet(d) + ',' + $yGet(d);\n      })\n      .join('L');\n  };\n</script>\n\n<g class=\"line-group\">\n  {#each $data as group}\n    <path\n      class='path-line'\n      d='{path(group.values)}'\n      stroke=\"{$zGet(group)}\"\n    ></path>\n  {/each}\n</g>\n\n<style>\n  .path-line {\n    fill: none;\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    stroke-width: 3px;\n  }\n</style>"},{"title":"./_components/AxisX.html.svelte","contents":"<!--\n  @component\n  Generates an HTML x-axis, useful for server-side rendered charts.  This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xScale } = getContext('LayerCake');\n\n  /** @type {Boolean} [gridlines=true] - Extend lines from the ticks into the chart space. */\n  export let gridlines = true;\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [baseline=false] – Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Boolean} [snapTicks=false] - Instead of centering the text on the first and the last items, align them to the edges of the chart. */\n  export let snapTicks = false;\n\n  /** @type {Function} [formatTick=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let formatTick = d => d;\n\n  /** @type {Number|Array|Function} [ticks] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [yTick=7] - The distance from the baseline to place each tick value, in pixels. */\n  export let yTick = 7;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n</script>\n\n<div class='axis x-axis' class:snapTicks>\n  {#each tickVals as tick, i (tick)}\n    {#if gridlines !== false}\n      <div class=\"gridline\" style='left:{$xScale(tick)}%;top: 0px;bottom: 0;'></div>\n    {/if}\n    {#if tickMarks === true}\n      <div class=\"tick-mark\" style='left:{$xScale(tick) + (isBandwidth ? $xScale.bandwidth() / 2 : 0)}%;height:6px;bottom: -6px;'></div>\n    {/if}\n    <div\n      class='tick tick-{ i }'\n      style='left:{$xScale(tick) + (isBandwidth ? $xScale.bandwidth() / 2 : 0)}%;top:100%;'>\n      <div\n        class=\"text\"\n        style='top:{(yTick)}px;'>{formatTick(tick)}</div>\n    </div>\n  {/each}\n  {#if baseline === true}\n    <div class=\"baseline\" style='top: 100%;width: 100%;'></div>\n  {/if}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .gridline {\n    border-left: 1px dashed #aaa;\n  }\n\n  .tick-mark {\n    border-left: 1px solid #aaa;\n  }\n  .baseline {\n    border-top: 1px solid #aaa;\n  }\n\n  .tick .text {\n    color: #666;\n    position: relative;\n    white-space: nowrap;\n    transform: translateX(-50%);\n  }\n  /* This looks a little better at 40 percent than 50 */\n  .axis.snapTicks .tick:last-child {\n    transform: translateX(-40%);\n  }\n  .axis.snapTicks .tick.tick-0 {\n    transform: translateX(40%);\n  }\n</style>"},{"title":"./_components/AxisY.html.svelte","contents":"<!--\n  @component\n  Generates an HTML y-axis.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, yScale } = getContext('LayerCake');\n\n  /** @type {Boolean} [gridlines=true] - Extend lines from the ticks into the chart space */\n  export let gridlines = true;\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [baseline=false] – Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Function} [formatTick=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let formatTick = d => d;\n\n  /** @type {Number|Array|Function} [ticks=4] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [xTick=-4] - How far over to position the text marker. */\n  export let xTick = -4;\n\n  /** @type {Number} [yTick=-1] - How far up and down to position the text marker. */\n  export let yTick = -1;\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<div class='axis y-axis' style='transform:translate(-{$padding.left}px, 0)'>\n  {#each tickVals as tick, i (tick)}\n    <div class='tick tick-{i}' style='top:{$yScale(tick) + (isBandwidth ? $yScale.bandwidth () / 2 : 0)}%;left:{$xRange[0]}%;'>\n      {#if gridlines !== false}\n        <div class=\"gridline\" style='top:0;left:{isBandwidth ? $padding.left : 0}px;right:-{$padding.left + $padding.right}px;'></div>\n      {/if}\n      {#if baseline !== false && i === 0}\n        <div class=\"gridline baseline\" style='top:0;left:{isBandwidth ? $padding.left : 0};right:-{$padding.left + $padding.right}px;'></div>\n      {/if}\n      {#if tickMarks === true}\n        <div class=\"tick-mark\" style='top:0;left:{isBandwidth ? $padding.left - 6 : 0}px;width:6px;'></div>\n      {/if}\n      <div\n        class=\"text\"\n        style='\n          top:{yTick}px;\n          left:{isBandwidth ? ($padding.left + xTick - 4) : 0}px;\n          transform: translate({isBandwidth ? '-100%' : 0}, {isBandwidth ? -50 - Math.floor($yScale.bandwidth() / -2) : '-100'}%);\n        '\n      >{formatTick(tick)}</div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline,\n  .text {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 12px;\n    width: 100%;\n    font-weight: 100;\n  }\n\n  .gridline {\n    border-top: 1px dashed #aaa;\n  }\n  .tick-mark {\n    border-top: 1px solid #aaa;\n  }\n\n  .baseline.gridline {\n    border-top-style: solid;\n  }\n\n  .tick .text {\n    color: #666;\n  }\n</style>"},{"title":"./_components/GroupLabels.html.svelte","contents":"<!--\n  @component\n  Generates HTML text labels for a nested data structure. It places the label near the y-value of the highest x-valued data point. This is useful for labeling the final point in a multi-series line chart, for example. It expects your data to be an array of objects where each has `values` field that is an array of data objects. It uses the `z` field accessor to pull the text label.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { max } from 'd3-array';\n\n  const { data, x, y, xScale, yScale, xRange, yRange, z } = getContext('LayerCake');\n\n  /* --------------------------------------------\n   * Title case the first letter\n   */\n  const cap = val => val.replace(/^\\w/, d => d.toUpperCase());\n\n  /* --------------------------------------------\n   * Put the label on the highest value\n   */\n  $: left = values => $xScale(max(values, $x)) /  Math.max(...$xRange);\n  $: top = values => $yScale(max(values, $y)) / Math.max(...$yRange);\n</script>\n\n{#each $data as group}\n  <div\n    class=\"label\"\n    style=\"\n      top:{top(group.values) * 100}%;\n      left:{left(group.values) * 100}%;\n    \"\n  >{cap($z(group))}</div>\n{/each}\n\n<style>\n  .label {\n    position: absolute;\n    transform: translate(-100%, -100%)translateY(1px);\n    font-size: 13px;\n  }\n</style>"},{"title":"./_components/SharedTooltip.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates a tooltip that works on multiseries datasets, like multiline charts. It creates a tooltip showing the name of the series and the current value. This version uses percentages so you can use it to render server-side. It finds the nearest data point using the [QuadTree.percent-range.html.svelte](https://layercake.graphics/components/QuadTree.percent-range.html.svelte) component.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { format } from 'd3-format';\n\n  import QuadTree from './QuadTree.percent-range.html.svelte';\n\n  const { data, width, yScale, config } = getContext('LayerCake');\n\n  const commas = format(',');\n  const titleCase = d => d.replace(/^\\w/, w => w.toUpperCase());\n\n  /** @type {Function} [formatTitle=d => d] - A function to format the tooltip title, which is `$config.x`. */\n  export let formatTitle = d => d;\n\n  /** @type {Function} [formatKey=d => titleCase(d)] - A function to format the series name. */\n  export let formatKey = d => titleCase(d);\n\n  /** @type {Function} [formatValue=d => isNaN(+d) ? d : commas(d)] - A function to format the value. */\n  export let formatValue = d => isNaN(+d) ? d : commas(d);\n\n  /** @type {Number} [offset=-20] - A y-offset from the hover point, in pixels. */\n  export let offset = -20;\n\n  /** @type {Array} [dataset] - The dataset to work off of—defaults to $data if left unset. You can pass something custom in here in case you don't want to use the main data or it's in a strange format. */\n  export let dataset = undefined;\n\n  const w = 150;\n  const w2 = w / 2;\n  let top = 0;\n\n  /* --------------------------------------------\n   * Sort the keys by the highest value\n   */\n  function sortResult(result) {\n    if (Object.keys(result).length === 0) return [];\n    const rows = Object.keys(result).filter(d => d !== $config.x).map(key => {\n      return {\n        key,\n        value: result[key]\n      };\n    }).sort((a, b) => b.value - a.value);\n\n    return rows;\n  }\n</script>\n\n<style>\n  .tooltip {\n    position: absolute;\n    font-size: 13px;\n    pointer-events: none;\n    border: 1px solid #ccc;\n    background: rgba(255, 255, 255, 0.85);\n    transform: translate(-50%, -100%);\n    padding: 5px;\n    z-index: 15;\n  }\n  .line {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    border-left: 1px dotted #666;\n    pointer-events: none;\n  }\n  .tooltip,\n  .line {\n    transition: left 250ms ease-out, top 250ms ease-out;\n  }\n  .title {\n    font-weight: bold;\n  }\n  .key {\n    color: #999;\n  }\n</style>\n\n<QuadTree\n  dataset={dataset || $data}\n  y='x'\n  let:x\n  let:y\n  let:visible\n  let:found\n  let:e\n>\n  {@const foundSorted = sortResult(found)}\n  {#if visible === true}\n    <div\n      style=\"left:{(x / 100) * $width }px;\"\n      class=\"line\"></div>\n    <div\n      class=\"tooltip\"\n      style=\"\n        width:{w}px;\n        display: { visible ? 'block' : 'none' };\n        top:calc({$yScale(foundSorted[0].value)}% + {offset}px);\n        left:{Math.min(Math.max(w2, (x / 100) * $width), $width - w2)}px;\"\n      >\n        <div class=\"title\">{formatTitle(found[$config.x])}</div>\n        {#each foundSorted as row}\n          <div class=\"row\"><span class=\"key\">{formatKey(row.key)}:</span> {formatValue(row.value)}</div>\n        {/each}\n    </div>\n  {/if}\n</QuadTree>"}],"modules":[],"componentModules":[],"componentComponents":[{"title":"./_components/QuadTree.percent-range.html.svelte","contents":"<!--\n  @component\n  Creates an interaction layer (in HTML) using [d3-quadtree](https://github.com/d3/d3-quadtree) to find the nearest datapoint to the mouse. This component creates a slot that exposes variables `x`, `y`, `found` (the found datapoint), `visible` (a Boolean whether any data was found) and `e` (the event object). This component works with a percent range so the `x` and `y` values coming back will be percentages.\n\n  The quadtree searches across both the x and y dimensions at the same time. But if you want to only search across one, set the `x` and `y` props to the same value. For example, the [shared tooltip component](https://layercake.graphics/components/SharedTooltip.html.svelte) sets `y='x'` since it's nicer behavior to only pick up on the nearest x-value.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { quadtree } from 'd3-quadtree';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  let visible = false;\n  let found = {};\n  let e = {};\n\n  /** @type {String} [x='x'] - The dimension to search across when moving the mouse left and right. */\n  export let x = 'x';\n\n  /** @type {String} [y='y'] - The dimension to search across when moving the mouse up and down. */\n  export let y = 'y';\n\n  /** @type {String} [searchRadius] - The number of pixels to search around the mouse's location. This is the third argument passed to [`quadtree.find`](https://github.com/d3/d3-quadtree#quadtree_find) and by default a value of `undefined` means an unlimited range. */\n  export let searchRadius = undefined;\n\n  /** @type {Array} [dataset] - The dataset to work off of—defaults to $data if left unset. You can pass something custom in here in case you don't want to use the main data or it's in a strange format. */\n  export let dataset = undefined;\n\n  $: xGetter = x === 'x' ? $xGet : $yGet;\n  $: yGetter = y === 'y' ? $yGet : $xGet;\n\n  function findItem (evt) {\n    e = evt;\n\n    const xLayerKey = `layer${x.toUpperCase()}`;\n    const yLayerKey = `layer${y.toUpperCase()}`;\n\n    const xLayerVal = (evt[xLayerKey] / (x === 'x' ? $width : $height)) * 100;\n    const yLayerVal = (evt[yLayerKey] / (y === 'y' ? $height : $width)) * 100;\n\n    found = finder.find(xLayerVal, yLayerVal, searchRadius) || {};\n\n    visible = Object.keys(found).length > 0;\n  }\n\n  $: finder = quadtree()\n    .extent([[-1, -1], [$width + 1, $height + 1]])\n    .x(xGetter)\n    .y(yGetter)\n    .addAll(dataset || $data);\n</script>\n\n<style>\n  .bg {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n</style>\n\n<div\n  class=\"bg\"\n  on:mousemove=\"{findItem}\"\n  on:mouseout=\"{() => visible = false}\"\n  on:blur=\"{() => visible = false}\"\n></div>\n<slot\n  x={xGetter(found) || 0}\n  y={yGetter(found) || 0}\n  {found}\n  {visible}\n  {e}\n></slot>"}],"csvs":[{"title":"./_data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}],"jsons":[]}